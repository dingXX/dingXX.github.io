<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>基于threeJs的N阶魔方数据结构与设计方法 | cynthia'blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基于threeJs的N阶魔方数据结构与设计方法</h1><a id="logo" href="/.">cynthia'blog</a><p class="description">她很懒，什么都没有留下</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基于threeJs的N阶魔方数据结构与设计方法</h1><div class="post-content"><p>之前，基于threeJs,做了个N阶魔方微信小游戏，支持魔方层级转动，整体转动，换阶，面识别的功能，最近再看代码，发现都不太看得懂自己写的东西了，在整个开发过程中，一些功能的实现是基于自己通过枚举情况找规律而设计实现的，现在代码上就只剩下最后的规律结果，却不太记得其中的找规律过程和当初的设计思路了，所以在趁代码重构时，在回顾一下当时的设计思路，记录下来~</p>
<ul>
<li>基于threejs的魔方数据结构</li>
<li>魔方转动手势的数据结构定义</li>
<li>根据转动手势，魔方转动的实现思路</li>
<li>屏幕滑动转为魔方转动手势</li>
<li>获取魔方各面信息的实现思路</li>
<li>从魔方面信息转为ThreeJS魔方实例</li>
</ul>
<h2 id="基于threejs的魔方数据结构"><a href="#基于threejs的魔方数据结构" class="headerlink" title="基于threejs的魔方数据结构"></a>基于threejs的魔方数据结构</h2><p>一开始的想法只是单纯的想做出一个3D魔方，可以在屏幕上实现转动就好。所以当时的思路就特别的简单，将N的3次幂的小方块堆成一个<code>N*N*N</code>的正方体就是一个简单的魔方了。</p>
<p>其中，有以下信息就能确定一个魔方: </p>
<ul>
<li>魔方的原点坐标 (<code>x</code>,<code>y</code>,<code>z</code>)</li>
<li>魔方的层级数 <code>layerNum</code>（N）</li>
<li>各个小方块的大小 <code>cubeWidth</code></li>
<li>魔方各面（也是小方块各面）的颜色值数组（new Array[6]） <code>colors = [&#39;#ff6b02&#39;, &#39;#dd422f&#39;,&#39;#ffffff&#39;, &#39;#fdcd02&#39;,&#39;#3d81f7&#39;, &#39;#019d53&#39;]</code> (右、左、上、下、前、后)</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>创建<code>N*N*N</code>个大小为<code>cubeWitdh</code>，各面颜色为<code>colors</code>的小方块</li>
<li>根据魔方原点坐标和方块大小，确定各个方块的位置</li>
</ol>
<h4 id="步骤1-创建小方块"><a href="#步骤1-创建小方块" class="headerlink" title="步骤1 创建小方块"></a>步骤1 创建小方块</h4><p>在threeJs中，可通过创建<a href="https://threejs.org/docs/index.html#api/zh/objects/Mesh" target="_blank" rel="external"><code>Mesh</code></a>实例来创建小方块，而一个Mesh，需要两个参数，形状（正方体BoxGeometry）和贴片（colors各面颜色贴片MeshLambertMaterial）</p>
<p>1-1. 创建单面颜色的贴片图片，用canvas绘制一个周围边为黑色，中间颜色为对应颜色的正方形<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFace</span>(<span class="params">rgbaColor</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</div><div class="line">    canvas.width = <span class="number">256</span>;</div><div class="line">    canvas.height = <span class="number">256</span>;</div><div class="line">    <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">    <span class="comment">//画一个宽高都是256的黑色正方形</span></div><div class="line">    ctx.fillStyle = <span class="string">'rgba(0,0,0,1)'</span>;</div><div class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="number">256</span>);</div><div class="line">    <span class="comment">//在内部用某颜色的16px宽的线再画一个宽高为224的圆角正方形并用改颜色填充</span></div><div class="line">    ctx.rect(<span class="number">16</span>, <span class="number">16</span>, <span class="number">224</span>, <span class="number">224</span>);</div><div class="line">    ctx.lineJoin = <span class="string">'round'</span>;</div><div class="line">    ctx.lineWidth = <span class="number">16</span>;</div><div class="line">    ctx.fillStyle = rgbaColor;</div><div class="line">    ctx.strokeStyle = rgbaColor;</div><div class="line">    ctx.stroke();</div><div class="line">    ctx.fill();</div><div class="line">    <span class="keyword">return</span> canvas;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1-2. 生成材质贴片数组，每个面一个颜色<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成材质贴片，每个面一个颜色</span></div><div class="line"><span class="keyword">let</span> materials = colors.map(<span class="function"><span class="params">color</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> face = util.createFace(color);</div><div class="line">    <span class="keyword">let</span> texture = <span class="keyword">new</span> THREE.Texture(face);</div><div class="line">    texture.needsUpdate = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</div><div class="line">        <span class="attr">map</span>: texture,</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>1-3. 创建方块几何体<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建小方块形状</span></div><div class="line"><span class="keyword">let</span> cubegeo = <span class="keyword">new</span> THREE.BoxGeometry(cubeWidth, cubeWidth, cubeWidth);</div></pre></td></tr></table></figure></p>
<p>1-4 创建方块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cubeDemo = <span class="keyword">new</span> THREE.Mesh(cubegeo, materials);</div></pre></td></tr></table></figure></p>
<p>做好第一步后，得到的是这样的<br><img src="/images/rubik-data-structure/cube.png" alt="小方块生成"></p>
<p>明明创建了多个方块，为啥只显示一个了？？那是因为所有方块都重叠了~下一步，我们需要计算各个方块的位置</p>
<h4 id="步骤2-计算小方块的位置"><a href="#步骤2-计算小方块的位置" class="headerlink" title="步骤2 计算小方块的位置"></a>步骤2 计算小方块的位置</h4><p>我们将魔方中心点作为原点(0,0,0)，那前左上角的小方块的中心点位置就是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前左上角的小方块的中心点位置</span></div><div class="line"><span class="comment">// 魔方宽度的一半-方块宽度的一半，x坐标是在负轴，取负数</span></div><div class="line"><span class="keyword">let</span> leftUpCx = - (layerNum / <span class="number">2</span> - <span class="number">0.5</span>) * cubeWidth; </div><div class="line"><span class="keyword">let</span> leftUpCy = (layerNum / <span class="number">2</span> - <span class="number">0.5</span>) * cubeWidth;</div><div class="line"><span class="keyword">let</span> leftUpCz = (layerNum / <span class="number">2</span> - <span class="number">0.5</span>) * cubeWidth;</div></pre></td></tr></table></figure></p>
<p>知道前左上角的方块位置之后，我们可以通过其他方块相对于左前上角的方块的位置，而得到其他方块的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每竖层 (从左到右)</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; layerNum; i++) &#123;</div><div class="line">    <span class="comment">// 一层9个</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; layerNum * layerNum; j++) &#123;</div><div class="line">        <span class="keyword">let</span> cube = cubeDemo.clone();</div><div class="line">        <span class="comment">//x,y,z为魔方中心的位置</span></div><div class="line">        cube.position.x = leftUpCx + (j % layerNum) * cubeWidth;</div><div class="line">        cube.position.y = leftUpCy - <span class="built_in">parseInt</span>(j / layerNum) * cubeWidth;</div><div class="line">        cube.position.z = leftUpCz - i * cubeWidth;</div><div class="line">        cubes.push(cube);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="魔方转动手势的数据结构定义"><a href="#魔方转动手势的数据结构定义" class="headerlink" title="魔方转动手势的数据结构定义"></a>魔方转动手势的数据结构定义</h2><p>在常见的魔方教程了，多数是用<code>FBUDLR</code>表示转动的层级，用<code>&#39;</code>表示转动的方向。但在Threejs中，物体的转动是根据转动轴、转动方向、转动角度来定义的。所以这里我自行定义了个转动手势字符串的数据结构,如，<code>xLine_0_1</code>(转动轴<em>对应方向的层级</em>是否逆时针) ,默认每次转动角度为90°</p>
<h3 id="转动轴"><a href="#转动轴" class="headerlink" title="转动轴"></a>转动轴</h3><p>魔方的转动轴只有<code>xLine(1,0,0)</code>(LR方向)、<code>yLine(0,1,0)</code>(DU方向) 、<code>zLine(0,0,1)</code>(BF方向)</p>
<h3 id="对应方向的层级"><a href="#对应方向的层级" class="headerlink" title="对应方向的层级"></a>对应方向的层级</h3><p>对应方向的层指的是 垂直于转动轴的魔方层，正轴值越大，层级数越低。<br>如以三阶魔方为例:</p>
<ul>
<li>转动轴为xLine,则最右侧层的层级为0，中间层的层级为1，最左边层的层级为2</li>
<li>转动轴为yLine,则最上层的层级为0，中间层为1，最下层为2</li>
<li>转动轴为zLine,则最前面层的层级为0，中间层为1，最后层为2</li>
</ul>
<p>由于魔方在平面上的投影最多只能展示3个面，如要看到其他的面，需要转动整个魔法，所以这里，定义了当层级为<code>-1</code>时，则认为在对应轴方向上转动整个魔方。</p>
<h3 id="是否逆时针"><a href="#是否逆时针" class="headerlink" title="是否逆时针"></a>是否逆时针</h3><p>是否逆时针 只的是相对于转动轴，是否逆时针转动。为0时，即转动角度为90°，为1是则转动角度为-90°</p>
<p>根据以上定义，我们可以将现实中常用的转动手势，转为这里定义的转动手势字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 获取面手势的枚举对象</div><div class="line">    * @param &#123;number&#125; layerNum 层级数</div><div class="line">    * @return &#123;object&#125; 面手势的枚举对象</div><div class="line">    */</div><div class="line"><span class="keyword">static</span> getFaceGestureEnum(layerNum) &#123;</div><div class="line">    <span class="keyword">const</span> lastLayerIndex = layerNum - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'F'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'zLine'</span>, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">        <span class="string">'F′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'zLine'</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">        <span class="string">'B'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'zLine'</span>, lastLayerIndex, <span class="number">1</span>),</div><div class="line">        <span class="string">'B′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'zLine'</span>, lastLayerIndex, <span class="number">0</span>),</div><div class="line">        <span class="string">'U'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'yLine'</span>, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">        <span class="string">'U′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'yLine'</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">        <span class="string">'D'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'yLine'</span>, lastLayerIndex, <span class="number">1</span>),</div><div class="line">        <span class="string">'D′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'yLine'</span>, lastLayerIndex, <span class="number">0</span>),</div><div class="line">        <span class="string">'R'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'xLine'</span>, lastLayerIndex, <span class="number">0</span>),</div><div class="line">        <span class="string">'R′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'xLine'</span>, lastLayerIndex, <span class="number">1</span>),</div><div class="line">        <span class="string">'L'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'xLine'</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">        <span class="string">'L′'</span>: <span class="keyword">this</span>.stringifyGesture(<span class="string">'xLine'</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取手势字符串</div><div class="line">*</div><div class="line">* @param  &#123;string&#125; turnAxis    旋转轴</div><div class="line">* @param  &#123;number&#125; layerIndex  旋转层级</div><div class="line">* @param  &#123;boolean&#125; isAntiClock 0 or 1 表示是否逆旋转</div><div class="line">*</div><div class="line">* @return &#123;string&#125;             手势数组</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> stringifyGesture(turnAxis, layerIndex, isAntiClock) &#123;</div><div class="line">    <span class="keyword">let</span> obj = [turnAxis, layerIndex, +isAntiClock];</div><div class="line">    <span class="keyword">return</span> obj.join(<span class="string">'_'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根据转动手势，魔方转动的实现思路"><a href="#根据转动手势，魔方转动的实现思路" class="headerlink" title="根据转动手势，魔方转动的实现思路"></a>根据转动手势，魔方转动的实现思路</h2><p>确定了转动手势的数据结构后，我们需要根据转动手势转动魔方。</p>
<h3 id="步骤1：确定需要转动的小方块"><a href="#步骤1：确定需要转动的小方块" class="headerlink" title="步骤1：确定需要转动的小方块"></a>步骤1：确定需要转动的小方块</h3><p>从转动手势中，我们可以明确的知道了转动轴方向和转动角度，但还缺少了转动的物体（哪些小方块需要转动）。所以，这里主要讲的是根据转动轴方向和转动层级，获取需要转动的小方块。</p>
<ul>
<li>当层级为-1时：转动层级为-1时，表示转动整个魔方，即所有的小方块都需要转动，则返回全部小方块</li>
<li>当层级不为1时，表示我们只转动其中一层，只要获取到这层的小方块即可</li>
</ul>
<h4 id="获取某层的小方块"><a href="#获取某层的小方块" class="headerlink" title="获取某层的小方块"></a>获取某层的小方块</h4><p>特定位置上的方块的坐标（这里指的是相对于魔方原点的坐标）是固定的，所以我们可以根据坐标确定。如获取xLine的0层，即找到坐标x为特定值的方块即可（由于计算精度问题，这里的判断不能用等于，需要判断是否在一定的区间里）</p>
<p>我采用的方法是给各个位置上的小方块编号，再根据各个层级与编号间的规律关系，从而判断小方块是否在对应层级中。</p>
<p>我这边的编号顺序是这样的，从zLine的第0层开始，从左到右，从上到下，从0开始。加+1编码。如图<br><img src="/images/rubik-data-structure/rubik.png" alt="方块的编码规律"></p>
<p>根据这个编号，我们能通过方块的编号和旋转轴，确定该方块在旋转轴的第几层<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getCubeLayerIndexEnum = &#123;</div><div class="line">    <span class="string">'zLine'</span>: <span class="function">(<span class="params">cubeIndex</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">let</span> num = layerNum * layerNum;</div><div class="line">        <span class="comment">// 取整</span></div><div class="line">        <span class="keyword">return</span> ~~(cubeIndex / num);</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'xLine'</span>: <span class="function">(<span class="params">cubeIndex</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> cubeIndex % layerNum;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'yLine'</span>: <span class="function">(<span class="params">cubeIndex</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">let</span> num = layerNum * layerNum;</div><div class="line">        <span class="keyword">return</span> ~~(cubeIndex % num / layerNum);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>知道方块的层级获取方法后，再逐一比较各个方块转动手势的层级是否一致，即可判断该层级上的方块有哪些<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 获取转动的小方块</div><div class="line">    * @param  &#123;string&#125; gesture 手势</div><div class="line">    * @return &#123;Array&#125;  需要操作的小方块数组</div><div class="line">    */</div><div class="line">getRotateCubesFromGesture(gesture) &#123;</div><div class="line">    <span class="comment">// gesture = 'xLine_0'</span></div><div class="line">    <span class="comment">// 存放转动小方块的数组</span></div><div class="line">    <span class="comment">// 获取转动的轴，和层级</span></div><div class="line">    <span class="keyword">let</span> &#123;</div><div class="line">        turnAxis,</div><div class="line">        layerIndex</div><div class="line">    &#125; = <span class="keyword">this</span>.constructor.parseGesture(gesture);</div><div class="line">    <span class="keyword">if</span> (layerIndex === <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cubes;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> cubes = <span class="keyword">this</span>.cubes.filter(<span class="function"><span class="params">cube</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getLayerIndex(turnAxis, cube.cubeIndex) === layerIndex;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> cubes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="步骤2：转动方块"><a href="#步骤2：转动方块" class="headerlink" title="步骤2：转动方块"></a>步骤2：转动方块</h3><p>从上面的步骤中，我们已知转动的方块、转动轴、转动角度了，那我们可以直接获取对应的旋转矩阵，再每个方块应用一下这个旋转矩阵即可。如果想要实现转动动画的话，可以计算每一帧间<strong>旋转角度差</strong>，从而得到对应的旋转矩阵，利用<code>requestAnimationFrame</code>函数实现动画<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取实际的转动矩阵</div><div class="line"> * @param &#123;vector3&#125; vector 旋转轴</div><div class="line"> * @param &#123;number&#125; rad 旋转角度</div><div class="line"> * @returns &#123;Matrix4&#125; 旋转矩阵</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getRotateAroundWorldMatrix</span>(<span class="params">vector, rad</span>) </span>&#123;</div><div class="line">    vector.normalize();</div><div class="line">    <span class="keyword">let</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4();</div><div class="line">    matrix4.makeRotationAxis(vector, rad);</div><div class="line">    <span class="keyword">return</span> matrix4;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 应用旋转矩阵</span></div><div class="line">cubes.forEach(<span class="function"><span class="params">cube</span> =&gt;</span> &#123;</div><div class="line">    cube.applyMatrix(rotateMatrix);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="步骤3：更新方块的编号"><a href="#步骤3：更新方块的编号" class="headerlink" title="步骤3：更新方块的编号"></a>步骤3：更新方块的编号</h3><p>由于方块转动了，不在原来的位置上，所以其对应的方块编号也要对应改变为新位置上的编号。用方块当前的位置和之前保留的初始状态对象数组比较，当方块的x,y,z与初始状态对象的x,y,z差不多时（差值小于方块大小的一半），则认为方块是处于那个位置，将编号设为对应的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 更新各个小方块实际所处的位置（ cubeIndex）</div><div class="line">    * @param &#123;array&#125; cubes 小方块数组</div><div class="line">    * @returns &#123;void&#125;</div><div class="line">    */</div><div class="line">updateCubeIndex(cubes) &#123;</div><div class="line">    <span class="keyword">let</span> initStatus = <span class="keyword">this</span>.initStatus;</div><div class="line">    cubes.forEach(<span class="function"><span class="params">cube</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">let</span> &#123;</div><div class="line">            x,</div><div class="line">            y,</div><div class="line">            z</div><div class="line">        &#125; = cube.position;</div><div class="line">        <span class="comment">// 位置相等的时候，就认为这是小方块新位置索引cubeIndex</span></div><div class="line">        <span class="keyword">let</span> cubeStatus = initStatus.find(<span class="function"><span class="params">temp</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> &#123;</div><div class="line">                <span class="attr">x</span>: sx,</div><div class="line">                <span class="attr">y</span>: sy,</div><div class="line">                <span class="attr">z</span>: sz</div><div class="line">            &#125; = temp;</div><div class="line">            <span class="keyword">let</span> deta = <span class="keyword">this</span>.params.cubeWidth / <span class="number">2</span>;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(x - sx) &lt;= deta &amp;&amp; <span class="built_in">Math</span>.abs(y - sy) &lt;= deta &amp;&amp; <span class="built_in">Math</span>.abs(z - sz) &lt;= deta;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (cubeStatus) &#123;</div><div class="line">            cube.cubeIndex = cubeStatus.cubeIndex;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="屏幕滑动转为魔方转动手势"><a href="#屏幕滑动转为魔方转动手势" class="headerlink" title="屏幕滑动转为魔方转动手势"></a>屏幕滑动转为魔方转动手势</h3></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/translate/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/代码片段/" style="font-size: 15px;">代码片段</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/JS-API/" style="font-size: 15px;">JS_API</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/svg/" style="font-size: 15px;">svg</a> <a href="/tags/flowChart/" style="font-size: 15px;">flowChart</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/koa2/" style="font-size: 15px;">koa2</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/20/2021-05-20-cors/">前端跨域问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/14/2020-07-nvm-alias-default-not-work/">nvm alias default 不起效问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/2020-07-lottie-web-img/">lottie-web的动画图片加载处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/13/2020-05-12-production-vue-devtools/">线上环境开启vue的dev-tools</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/2020-05-10-double-equal/">js的宽松相等</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/21/2020-04-vue-lifecycle/">vue组件的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/2020-04-two-column-layout/">两栏布局实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/2020-04-file-download-by-web/">web前端下载文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/23/2019-07-es5-es6-class/">ES5 & ES6 的类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/15/2019-07-set-and-map/">Set & Map 数据结构</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">cynthia'blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>